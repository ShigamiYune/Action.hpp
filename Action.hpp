#pragma once
#ifndef ACTION_H
#define ACTION_H

#pragma region ACTION_GEN
#define ACTION_GEN_PARAMS_1(T1)   T1 a1
#define ACTION_GEN_PARAMS_2(T1, T2)   T1 a1, T2 a2
#define ACTION_GEN_PARAMS_3(T1, T2, T3)   T1 a1, T2 a2, T3 a3
#define ACTION_GEN_PARAMS_4(T1, T2, T3, T4)   T1 a1, T2 a2, T3 a3, T4 a4
#define ACTION_GEN_PARAMS_5(T1, T2, T3, T4, T5)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5
#define ACTION_GEN_PARAMS_6(T1, T2, T3, T4, T5, T6)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6
#define ACTION_GEN_PARAMS_7(T1, T2, T3, T4, T5, T6, T7)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7
#define ACTION_GEN_PARAMS_8(T1, T2, T3, T4, T5, T6, T7, T8)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8
#define ACTION_GEN_PARAMS_9(T1, T2, T3, T4, T5, T6, T7, T8, T9)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9
#define ACTION_GEN_PARAMS_10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10
#define ACTION_GEN_PARAMS_11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11
#define ACTION_GEN_PARAMS_12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12
#define ACTION_GEN_PARAMS_13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13
#define ACTION_GEN_PARAMS_14(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14
#define ACTION_GEN_PARAMS_15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15
#define ACTION_GEN_PARAMS_16(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16
#define ACTION_GEN_PARAMS_17(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17
#define ACTION_GEN_PARAMS_18(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18
#define ACTION_GEN_PARAMS_19(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19
#define ACTION_GEN_PARAMS_20(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)   T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9, T10 a10, T11 a11, T12 a12, T13 a13, T14 a14, T15 a15, T16 a16, T17 a17, T18 a18, T19 a19, T20 a20

#define ACTION_GEN_VAR_1(T1)   a1
#define ACTION_GEN_VAR_2(T1, T2)   a1, a2
#define ACTION_GEN_VAR_3(T1, T2, T3)   a1, a2, a3
#define ACTION_GEN_VAR_4(T1, T2, T3, T4)   a1, a2, a3, a4
#define ACTION_GEN_VAR_5(T1, T2, T3, T4, T5)   a1, a2, a3, a4, a5
#define ACTION_GEN_VAR_6(T1, T2, T3, T4, T5, T6)   a1, a2, a3, a4, a5, a6
#define ACTION_GEN_VAR_7(T1, T2, T3, T4, T5, T6, T7)   a1, a2, a3, a4, a5, a6, a7
#define ACTION_GEN_VAR_8(T1, T2, T3, T4, T5, T6, T7, T8)   a1, a2, a3, a4, a5, a6, a7, a8
#define ACTION_GEN_VAR_9(T1, T2, T3, T4, T5, T6, T7, T8, T9)   a1, a2, a3, a4, a5, a6, a7, a8, a9
#define ACTION_GEN_VAR_10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10
#define ACTION_GEN_VAR_11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11
#define ACTION_GEN_VAR_12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12
#define ACTION_GEN_VAR_13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13
#define ACTION_GEN_VAR_14(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14
#define ACTION_GEN_VAR_15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15
#define ACTION_GEN_VAR_16(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16
#define ACTION_GEN_VAR_17(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17
#define ACTION_GEN_VAR_18(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18
#define ACTION_GEN_VAR_19(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19
#define ACTION_GEN_VAR_20(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20)   a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20

#define ACTION_GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,NAME, ...) NAME

#define ACTION_GEN_PARAMS(...) \
    ACTION_GET_MACRO(__VA_ARGS__, ACTION_GEN_PARAMS_20, ACTION_GEN_PARAMS_19, ACTION_GEN_PARAMS_18, ACTION_GEN_PARAMS_17, ACTION_GEN_PARAMS_16, ACTION_GEN_PARAMS_15, ACTION_GEN_PARAMS_14, ACTION_GEN_PARAMS_13, ACTION_GEN_PARAMS_12, ACTION_GEN_PARAMS_11, ACTION_GEN_PARAMS_10, ACTION_GEN_PARAMS_9, ACTION_GEN_PARAMS_8, ACTION_GEN_PARAMS_7, ACTION_GEN_PARAMS_6, ACTION_GEN_PARAMS_5, ACTION_GEN_PARAMS_4, ACTION_GEN_PARAMS_3, ACTION_GEN_PARAMS_2, ACTION_GEN_PARAMS_1)(__VA_ARGS__)

#define ACTION_GEN_VAR(...) \
    ACTION_GET_MACRO(__VA_ARGS__, ACTION_GEN_VAR_20, ACTION_GEN_VAR_19, ACTION_GEN_VAR_18, ACTION_GEN_VAR_17, ACTION_GEN_VAR_16, ACTION_GEN_VAR_15, ACTION_GEN_VAR_14, ACTION_GEN_VAR_13, ACTION_GEN_VAR_12, ACTION_GEN_VAR_11, ACTION_GEN_VAR_10, ACTION_GEN_VAR_9, ACTION_GEN_VAR_8, ACTION_GEN_VAR_7, ACTION_GEN_VAR_6, ACTION_GEN_VAR_5, ACTION_GEN_VAR_4, ACTION_GEN_VAR_3, ACTION_GEN_VAR_2, ACTION_GEN_VAR_1)(__VA_ARGS__)

#define ACTION_SIG_TO_PARAMS_I(...) __VA_ARGS__
#define ACTION_SIG_TO_PARAMS(X) ACTION_SIG_TO_PARAMS_I X

#pragma endregion

#include <vector>
#include <memory>

struct KeyEvent{
    const void* ptr;
    const wchar_t* name;
};

template<typename Signature> class ObjectEvent;
template<typename Return, typename ... Args>
class ObjectEvent<Return(Args...)>{
public:
    virtual ~ObjectEvent(){}
    virtual Return invoke(Args ...) = 0;
    virtual bool compare(const KeyEvent& key) const {return false;}
};

template<typename Signature> class Action;
template<typename Return, typename ... Args>
class Action<Return(Args...)> {
    std::vector<std::unique_ptr<ObjectEvent<Return(Args ...)>>> event;
public:
    void add_event(std::unique_ptr<ObjectEvent<Return(Args ...)>> _event){
        event.push_back(std::move(_event));
    }

    Return invoke(Args ... arg){
        std::size_t size = event.size();
        if(size == 0) return {}; 
        size -= 1;
        for(int i = 0; i < size; i++){
            event[i]->invoke(arg...);
        }
        return event[size]->invoke(arg...);
    }

    Action& operator+=(std::unique_ptr<ObjectEvent<Return(Args ...)>> _event) {
        event.push_back(std::move(_event));
        return *this;
    }

    Action& operator-=(const KeyEvent& key) {
        auto it = std::remove_if(event.begin(), event.end(),
            [key](const std::unique_ptr<ObjectEvent<Return(Args ...)>>& e) {
                return e.get()->compare(key);
            });

        event.erase(it, event.end());
        return *this;
    }

    std::size_t size() const { return event.size(); }
    void clear() { event.clear(); }

    Return invoke_with_key(const KeyEvent& key, Args ... arg){
        std::size_t size = event.size();
        if(size == 0) return {}; 
        for(int i = 0; i < size; i++){
            if(event[i].get()->compare(key)) return event[i].get()->invoke(arg ...);
        }
        return {}; 
    }
};

template<typename ... Args>
class Action<void(Args...)> {
    std::vector<std::unique_ptr<ObjectEvent<void(Args ...)>>> event;
public:
    void add_event(std::unique_ptr<ObjectEvent<void(Args ...)>> _event){
        event.push_back(std::move(_event));
    }

    void invoke(Args ... arg){
        std::size_t size = event.size();
        if(size == 0) return; 
        size -= 1;
        for(int i = 0; i < size; i++){
            event[i]->invoke(arg...);
        }
        event[size]->invoke(arg...);
    }

    Action& operator+=(std::unique_ptr<ObjectEvent<void(Args ...)>> _event) {
        event.push_back(std::move(_event));
        return *this;
    }

    Action& operator-=(const KeyEvent& key) {
        auto it = std::remove_if(event.begin(), event.end(),
            [key](const std::unique_ptr<ObjectEvent<void(Args ...)>>& e) {
                return e.get()->compare(key);
            });

        event.erase(it, event.end());
        return *this;
    }

    std::size_t size() const { return event.size(); }
    void clear() { event.clear(); }

    void invoke_with_key(const KeyEvent& key, Args ... arg){
        std::size_t size = event.size();
        if(size == 0) return; 
        for(int i = 0; i < size; i++){
            if(event[i].get()->compare(key)) event[i].get()->invoke(arg ...);
        }
    }
};

template<typename T, typename Signature> class Lambda_Capture;
template<typename T, typename Return, typename ... Args>
class Lambda_Capture<T, Return(Args ...)> : public ObjectEvent<Return(Args ...)> {
    public:
    T fn; Lambda_Capture(T _fn) : fn(_fn) {}
    Return invoke(Args ... args) override { return fn(args ...);}
};

#define WIDEN2(x) L##x
#define WIDEN(x) WIDEN2(x)

#define EVENT_MEMBER(CLASS, FUNC, PTR, RET, SIG)                                                                        \
[PTR] () {                                                                                                              \
    struct Event : ObjectEvent<RET(SIG)>{                                                                               \
        CLASS* ptr = nullptr; Event(CLASS* _ptr) : ptr(_ptr){}                                                          \
        RET invoke(ACTION_GEN_PARAMS(ACTION_SIG_TO_PARAMS(SIG))) override {                                             \
             return ptr->FUNC(ACTION_GEN_VAR(ACTION_SIG_TO_PARAMS(SIG)));                                               \
        }                                                                                                               \
        bool compare(const KeyEvent& key) const override {                                                              \
             return ptr == key.ptr && wcscmp(key.name, WIDEN(#FUNC)) == 0;                                              \
        }                                                                                                               \
    };                                                                                                                  \
    return std::make_unique<Event>(PTR);                                                                                \
}()

#define EVENT_STATIC_MEMBER(CLASS, FUNC, CALL, RET, SIG)                                                                \
[] () {                                                                                                                 \
    struct Event : ObjectEvent<RET(SIG)>{                                                                               \
        RET invoke(ACTION_GEN_PARAMS(ACTION_SIG_TO_PARAMS(SIG))) override {                                             \
             return CALL(ACTION_GEN_VAR(ACTION_SIG_TO_PARAMS(SIG)));                                                    \
        }                                                                                                               \
        bool compare(const KeyEvent& key) const override {                                                              \
             return &CALL == key.ptr && wcscmp(key.name, WIDEN(#FUNC)) == 0;                                            \
        }                                                                                                               \
    };                                                                                                                  \
    return std::make_unique<Event>();                                                                                   \
}()

#define EVENT_GLOBAL(FUNC, CALL, RET, SIG)                                                                              \
[] () {                                                                                                                 \
    struct Event : ObjectEvent<RET(SIG)>{                                                                               \
        RET invoke(ACTION_GEN_PARAMS(ACTION_SIG_TO_PARAMS(SIG))) override {                                             \
             return CALL(ACTION_GEN_VAR(ACTION_SIG_TO_PARAMS(SIG)));                                                    \
        }                                                                                                               \
        bool compare(const KeyEvent& key) const override {                                                              \
             return reinterpret_cast<const void*>(                                                                      \
                reinterpret_cast<uintptr_t>(&CALL)) == key.ptr && wcscmp(key.name, WIDEN(#FUNC)) == 0;                  \
        }                                                                                                               \
    };                                                                                                                  \
    return std::make_unique<Event>();                                                                                   \
}()

#define EVENT_LAMBDA_CAPTURE(FUNC, RET, SIG)                                                                            \
[FUNC] () {                                                                                                             \
    struct Event : Lambda_Capture<decltype(FUNC), RET(SIG)>{                                                            \
        Event(decltype(FUNC) _fn) : Lambda_Capture(_fn){}                                                               \
        RET invoke(ACTION_GEN_PARAMS(ACTION_SIG_TO_PARAMS(SIG))) override {                                             \
             return fn(ACTION_GEN_VAR(ACTION_SIG_TO_PARAMS(SIG)));                                                      \
        }                                                                                                               \
        bool compare(const KeyEvent& key) const override {                                                              \
             return wcscmp(key.name, WIDEN(#FUNC)) == 0;                                                                \
        }                                                                                                               \
    };                                                                                                                  \
    return std::make_unique<Event>(FUNC);                                                                               \
}()

#define GET_KEY_EVENT_LAMBDA_CAPTURE(FUNC) KeyEvent(nullptr, WIDEN(#FUNC))
#define GET_KEY_EVENT_MEMBER(CLASS, FUNC, INSTANCE_PTR) KeyEvent(INSTANCE_PTR, WIDEN(#FUNC))
#define GET_KEY_EVENT_MEMBER_STATIC(CLASS, FUNC, CALL) KeyEvent(&CALL, WIDEN(#FUNC))
#define GET_KEY_EVENT_GLOBAL(FUNC, CALL) KeyEvent(\
    reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(&CALL)), WIDEN(#FUNC))
#endif
